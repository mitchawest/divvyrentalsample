import express from 'express';
import { Server } from 'http';
import helmet from 'helmet';
import bodyParser from 'body-parser';
import fs from 'fs';

import router from '@app/routes';
import logger from '@service/logger.service';
import { LEVELS, COLORS } from '@util/enums';
import { identifyRequest, corsHandler } from '@util/utils';
import errorHandler from '@util/errorHandler';
import swaggerUiService from '@service/swaggerui.service';
import tripDataService from '@service/tripData.service';

const init = async (): Promise<Server> => {
  let server: Server = null;
  try {
    const app = express();

    /* Initialize logger with log level enumeration */
    logger.init(LEVELS, COLORS);

    /* for parsing application/json, www-form-urlencoded, and multipart/form-data */
    app.use(bodyParser.urlencoded({ extended: true }));
    app.use(bodyParser.json());

    /* Add request identifier if not present */
    app.use(identifyRequest);

    /* Allow or disallow origins */
    app.use(corsHandler);

    /* use to protect with strict transport security */
    app.use(
      helmet.hsts({
        maxAge: 10886400000, // Must be at least 18 weeks to be approved
        includeSubDomains: true, // Must be enabled to be approved
        preload: true,
      }),
    );

    /* X-XSS-Protection prevent reflected XSS attacks */
    app.use(helmet.xssFilter());

    /* Import router */
    app.use(router);

    /* Handle any errors generated by routes or previous handlers */
    app.use(errorHandler);

    /* Configure swagger UI */
    swaggerUiService.init('openapi.yaml', { supportHeaderParams: true, customSiteTitle: process.env.APINAME });

    /* Load trip data if exists */
    if (fs.existsSync('./import/Divvy_Trips_2019_Q2')) tripDataService.init('./import/Divvy_Trips_2019_Q2');

    const port = process.env.PORT || 80;

    server = app.listen(port, () => logger.info(`${process.env.NAMESPACE} server listening on port: ${port}`));

    /* Cleans up queue on process exit */
    const exitHandler = async (options: { cleanup: boolean, exit: boolean}, exitCode: number): Promise<void> => {
      if (options.cleanup) process.stdout.write('Cleaning processes\n');
      if (exitCode || exitCode === 0) process.stdout.write(`Exit code: ${exitCode}\n`);
      if (options.exit) process.exit(exitCode);
    };
    /* Cleanup when process closes */
    process.on('exit', exitHandler.bind(null, { cleanup: true }));
    /* Cleanup on ctrl+c */
    process.on('SIGINT', exitHandler.bind(null, { exit: true }));
    // catches "kill pid" (for example: nodemon restart)
    process.on('SIGUSR1', exitHandler.bind(null, { exit: true }));
    process.on('SIGUSR2', exitHandler.bind(null, { exit: true }));
    // catches uncaught exceptions
    process.on('uncaughtException', exitHandler.bind(null, { exit: true }));
  } catch (err) {
    if (logger.debug) {
      logger.debug(err);
    } else process.stdout.write(err);
    if (logger.critical) {
      logger.critical(`Failed to run. Error: ${err}. Stopping node process.`);
    } else {
      process.stdout.write(`Failed to run. Error: ${err}. Stopping node process.`);
    }
    setTimeout(() => process.exit(1), 5000);
  }
  return server;
};

export default init;
